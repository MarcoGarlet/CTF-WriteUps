from Crypto.Util.number import *
from functools import reduce
from factordb.factordb import FactorDB
import gmpy2

enc = 493411990714034701192036868925033382533813449023272468886834417275865894890277610897602010608126211732489729110637453412478527735277532858305194132432995412335314758844973458067236971260497417393244304994147175160121126866274637094642084286422204250530071767179407437175780827344723433812174890560874797281085881372866235919836442489439131953350250339903321616150128653702980111364606793773693115742802148096105255600570826866081538329662788508308910574300106675
pubkey = (58899560795422629508383709585815596674993413635981165980320127271644038316448725758306722451998784991954419091526089159750869500335163383766827243981828688851948124591111627934859094536105678156714083380927689539385480719433890644570016706624506640312364077682372260047937960244512523766943378334280751887151, 10035997187541816220681016469393172095726015614633459513695480820099536637633364416223346540578858375371324216891862234038678667156169323844411428795236483)
n=591115826490309729652229755684270397434097686987727132849445065006972555773162612455224258285657736679144410500970377961890880097323795620295567282728281205781926398127386353388403223985287571516890214047163630378154565164133069511631420478272985759890740867426338066843463645285144809736210454105484643766386941651135723254162002945871342384329597971199753078727923204118362911548120474585611933295292478563468192801468080852784566136578969407694226961574129933
p2_p3 = gmpy2.div(pubkey[0],pubkey[1])
print('p2_p3 = {}'.format(p2_p3))

f = FactorDB(pubkey[1])
f.connect()
p0,p1 = f.get_factor_list()
print('p0 = {}'.format(p0))
print('p1 = {}'.format(p1))

'''
Since n=p0**2*p1**2*p2*p3 I need to factorize p2_p3 to determine that value and find mul iverse mod phi(n) of e, 
however if our plaintext is less than p0**2*p1**2 (or some combination of the base such that e % phi(reduced_n)==1) 
than I can rewrite enc as enc % reduced_n and try to find inverse multiplicative on phi(reduced_n).

'''


phi = gmpy2.mul(gmpy2.mul(p0,p0-1),gmpy2.mul(p1,p1-1))

e = 65537
d = inverse(e,phi)

'''

def GenerateKey(length):
        Primes = [getPrime(length) for _ in range(4)]
        modulus = (Primes[0] * Primes[1] * Primes[2] * Primes[3], Primes[0] * Primes[1])
        return modulus
'''



def decrypt(c,d, modulus):
  '''
  65537 inv mul totient(modulus[0] * modulus[1]) = primes[0]-1*primes[1]
  '''
  #enc = pow(bytes_to_long(msg.encode('utf-8')), 65537, modulus[0] * modulus[1])
  dec = pow(c,d,modulus)
  print(dec)
  return dec

enc = enc % (p0*p0*p1*p1) # not necessary 
m = decrypt(enc,d,p0*p0*p1*p1)
m = long_to_bytes(m)
print(m.decode('utf-8','ignore'))


